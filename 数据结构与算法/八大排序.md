

## 插入排序

### 直接插入排序

```c
// 插入排序
void InsertSort(int* a, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		int end = i;
		int tmp = a[end + 1];
		//从0到end是有序的，插入后则从[0,end+1]是有序
		

		//移动数据再插入
		while (end >= 0)
		{
			if (a[end] > tmp)//调升降序
				a[end + 1] = a[end--];
			else
				break;
		}
		a[end + 1] = tmp;
	}

}
```









### 希尔排序

```c
// 希尔排序
void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap > 1)
	{
		gap = gap / 3 + 1;
		for (int i = 0; i < n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];


			//移动数据再插入
			while (end >= 0)
			{
				if (a[end] > tmp)//调升降序
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}
```







## 选择排序

### 选择排序

```c
// 选择排序
// 
void SelectSort(int* a, int n)
{
	int begin = 0, end = n - 1;
	while (begin < end)
	{
		int maxi = begin, mini = begin;
		for (int i = begin; i <= end; ++i)
		{
			if (a[maxi] < a[i])
			{
				maxi = i;
			}
			if (a[mini] > a[i])
			{
				mini = i;
			}
		}
		Swap(&a[begin], &a[maxi]);
		//此时如果最小值下标在begin，交换一下，改变升降序时需改此处
		if (mini == begin)
			mini = maxi;
		Swap(&a[end], &a[mini]);

		begin++;
		end--;
	}
}
```







### 堆排序

```c
// 堆排序
void AdjustDown(int* pa, int N, int parent)
{
	assert(pa);
	int MinChild = parent * 2 + 1;
	while (MinChild < N)
	{
		//if (MinChild + 1 < N && pa[MinChild] < pa[MinChild + 1])//大堆
		if (MinChild + 1 < N && pa[MinChild] > pa[MinChild + 1])//小堆
		{
			MinChild += 1;
		}
		//if (pa[MinChild] > pa[parent])//大堆
		if (pa[MinChild] < pa[parent])//小堆
		{
			Swap(&pa[MinChild], &pa[parent]);
			parent = MinChild;
			MinChild = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HeapSort(int* a, int n)
{
	assert(a);

	//建堆
	int i = 0;
	for (i = (n - 2) / 2; i >= 0; --i)//建小堆
	{
		AdjustDown(a, n, i);
	}

	for (i = 1; i < n; ++i)
	{
		Swap(&a[0], &a[n - i]);//置后，降序
		AdjustDown(a, n - i, 0);
	}

}
```









## 交换排序

### 冒泡排序

```c
// 冒泡排序
void BubbleSort(int* a, int n)
{
	for (int i = 0; i < n; i++)
	{
		int flag = 1;
		for (int j = 0; j < n - i - 1; j++)//调整升降序
		{
			if (a[j] < a[j + 1])
			{
				Swap(&a[j], &a[j + 1]);
				flag = 0;
			}
		}
		if (flag)
			break;
	}
}
```







### 快速排序

```c
int GetMid(int* a, int left, int right)
{
	int mid = (right + left) / 2;

	if ((a[mid] >= a[right] && a[mid] <= a[left]) || (a[mid] >= a[left] && a[mid] <= a[right]))
		return mid;
	else if ((a[left] <= a[right] && a[left] >= a[mid]) || (a[left] <= a[mid] && a[left] >= a[right]))
		return left;
	else
		return right;
}

// 快排的插入排序模块
void QuickInsertSort(int* a, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		int end = i;
		int tmp = a[end + 1];
		//从0到end是有序的，插入后则从[0,end+1]是有序


		//移动数据再插入
		while (end >= 0)
		{
			if (a[end] > tmp)//调升降序
			{
				a[end + 1] = a[end];
				end--;
			}
			else
				break;
		}
		a[end + 1] = tmp;
	}

}

// 快速排序hoare版本
int PartSort1(int* a, int left, int right)
{
	int key = GetMid(a, left, right);
	Swap(&a[key], &a[left]);
	key = left;
	while (left < right)
	{
		while (a[right] >= a[key] && left < right)
			right--;

		while (a[left] <= a[key] && left < right)
			left++;

		if (left < right)
			Swap(&a[left], &a[right]);
	}
	Swap(&a[key], &a[left]);
	return left;
}

// 快速排序挖坑法
int PartSort2(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&a[mid], &a[left]);
	int key = a[left];
	while (left < right)
	{
		while (left < right && a[right] >= key)
			right--;
	
		if (left < right)
			a[left] = a[right];

		while (left < right && a[left] <= key)
			left++;

		if (left < right)
			a[right] = a[left];
	}
	a[right] = key;
	return right;
}


// 快速排序前后指针法
int PartSort3(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&a[mid], &a[left]);
	int key = a[left];
	int prev = left, cur = left + 1;
	while (cur <= right)
	{
		while (cur <= right && a[cur] >= key)
			++cur;

		if (prev < cur && cur <= right)
			Swap(&a[++prev], &a[cur]);

		++cur;
	}
	Swap(&a[left], &a[prev]);
	return prev;
}

void QuickSort(int* a, int left, int right)//right是闭区间右边界[left,right]
{
	if (left >= right)
		return;	

	if (right - left <= 16)//数据量小的序列直接使用插入排序
	{
		QuickInsertSort(a + left, right - left + 1);
	}
	else
	{
		//对此次序列进行排序
	    int key = PartSort1(a, left, right);
		//int key = PartSort2(a, left, right);
		//int key = PartSort3(a, left, right);

		//左半序列递归
		QuickSort(a, left, key - 1);
		//右半部分递归
		QuickSort(a, key + 1, right);
	}


}



// 快速排序 非递归实现
void QuickSortNonR(int* a, int left, int right)
{
	Stack sort;
	StackInit(&sort);
	StackPush(&sort, left);
	StackPush(&sort, right);
	while (!StackEmpty(&sort))
	{
		right = StackTop(&sort);
		StackPop(&sort);
		left = StackTop(&sort);
		StackPop(&sort);

		if (left >= right)
			continue;

		if (right - left <= 16)//数据量小的序列直接使用插入排序
		{
			QuickInsertSort(a + left, right - left + 1);
		}
		else
		{
			//对此次序列进行排序
			int key = PartSort2(a, left, right);
			StackPush(&sort, key + 1);
			StackPush(&sort, right);

			StackPush(&sort, left);
			StackPush(&sort, key - 1);
		}


	}


	StackDestroy(&sort);
}
```





## 归并排序

```c
void Merge(int* a, int* disposal, int left, int right)
{
	if (left >= right)
		return;

	int mid = (left + right) / 2;
	Merge(a, disposal, left, mid);
	Merge(a, disposal, mid + 1, right);

	//选取数据合并
	int Ri = mid + 1;
	int Li = left;
	int i = 0;
	while (Li <= mid && Ri <= right)
	{
		if (a[Li] < a[Ri])//调整升降序
		{
			disposal[left + i] = a[Li];
			Li++;
		}
		else
		{
			disposal[left + i] = a[Ri];
			Ri++;
		}
		i++;
	}
	//将剩下的另一个未拷贝的数组继续拷贝
	while (Li <= mid)
	{
		disposal[left + i] = a[Li];
		Li++;
		i++;
	}
	while (Ri <= right)
	{
		disposal[left + i] = a[Ri];
		Ri++;
		i++;
	}

	//拷贝回原位置
	while (left <= right)
	{
		a[left] = disposal[left];
		left++;
	}
}


// 归并排序递归实现
void MergeSort(int* a, int n)
{
	//申请一块空间用于处理排序数据
	int* disposal = (int*)malloc(sizeof(int) * n);
	if (disposal == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}

	//将处理的过程交给函数模块去递归进行
	Merge(a, disposal, 0, n - 1);


	free(disposal);
	disposal = NULL;
}


// 归并排序非递归实现
void MergeSortNonR(int* a, int n)
{
	//申请一块空间用于处理排序数据
	int* disposal = (int*)malloc(sizeof(int) * n);
	if (disposal == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}
	
	int gap = 1;//迭代器
	while (gap < n)
	{
		for (int i = 0; i < n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;

			//end1越界
			if (end1 >= n)
			{
				break;
			}
			//begin2越界
			if (begin2 >= n)
			{
				break;
			}
			//end2越界
			if (end2 >= n)
			{
				end2 = n - 1;
			}
			//选取数据合并
			int j = i;
			while (begin1 <= end1 && begin2 <= end2)
			{
				if (a[begin1] < a[begin2])//调升降序
					disposal[j++] = a[begin1++];
				else
					disposal[j++] = a[begin2++];
			}

			while (begin1 <= end1)
				disposal[j++] = a[begin1++];

			while (begin2 <= end2)
				disposal[j++] = a[begin2++];

			//拷贝回去
			memcpy(a + i, disposal + i, sizeof(int) * (end2 - i + 1));
		}
		gap *= 2;
	}
	

	free(disposal);
	disposal = NULL;
}
```





```c
// 计数排序
void CountSort(int* a, int n)
{
	int i = 0;
	int max = a[0], min = a[0];
	for (i = 0; i < n; i++)
	{
		if (max < a[i])
			max = a[i];
		if (min > a[i])
			min = a[i];
	}

	//申请一块空间记录数字出现次数
	int* record = (int*)calloc((max - min + 1), sizeof(int));
	if (record == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}

	//计数
	for (i = 0; i < n; i++)
		record[a[i] - min]++;

	int j = 0;
	for (i = 0; i < (max - min + 1); i++)
	{
		while (record[i])
		{
			a[j] = i + min;
			record[i]--;
			j++;
		}
	}

	free(record);
	record = NULL;
}
```



```c
int GetKey(int n, int k)
{
	int key = 0;
	while (k >= 0)
	{
		key = n % 10;
		n /= 10;
		k--;
	}
	return key;
}

void Classify(int* a,int n,Queue* RS,int k)
{
	for (int i = 0; i < n; i++)
	{
		int KeyI = GetKey(a[i], k);
		QueuePush(&RS[KeyI], a[i]);
	}
}

void Recycle(int* a,Queue* RS)
{
	int j = 0;
	for (int i = 0; i < Radix; i++)
	{
		while (!QueueEmpty(&RS[i]))
		{
			a[j++] = QueueFront(&RS[i]);
			QueuePop(&RS[i]);
		}
	}
}

//基数排序
void Radix_Sort(int* a, int n)
{
	Queue RS[Radix];
	for (int i = 0; i < Radix; i++)
	{
		QueueInit(&RS[i]);
	}
	for (int i = 0; i < K; i++)
	{
		//按基准分类数据
		Classify(a, n, RS, i);
		//从基准队列中返回数据
		Recycle(a, RS);
	}
	for (int i = 0; i < Radix; i++)
	{
		QueueDestroy(&RS[i]);
	}
}
```

