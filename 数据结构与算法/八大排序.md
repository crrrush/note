

## 插入排序

### 直接插入排序

```c++
// C version
void InsertSort(int* a, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		int end = i;
		int tmp = a[end + 1];
		//从0到end是有序的，插入后则从[0,end+1]是有序
		

		//移动数据再插入
		while (end >= 0)
		{
			if (a[end] > tmp)//调升降序
				a[end + 1] = a[end--];
			else
				break;
		}
		a[end + 1] = tmp;
	}

}


// CPP version
void insert_sort(std::vector<int>& v)
{
    for (int i = 0; i < v.size() - 1; ++i)
    {
        int end_pos = i;
        int tmp = v[i + 1];

        while (end_pos >= 0)
        {
            if (std::less<int>()(tmp, v[end_pos]))
                v[end_pos + 1] = v[end_pos];
            else
                break;

            --end_pos;
        }
        v[end_pos + 1] = tmp;
    }
}

template<class compare>
void insert_sort(std::vector<int>& v, compare cmp)
{
    for (int i = 0; i < v.size() - 1; ++i)
    {
        int end_pos = i;
        int tmp = v[i + 1];
        while (end_pos >= 0)
        {
            if (cmp(tmp, v[end_pos]))
                v[end_pos + 1] = v[end_pos];
            else
                break;

            --end_pos;
        }
        v[end_pos + 1] = tmp;
    }
}
```







### 希尔排序

```c++
// C version
void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap > 1)
	{
		gap = gap / 3 + 1;
		for (int i = 0; i < n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];


			//移动数据再插入
			while (end >= 0)
			{
				if (a[end] > tmp)//调升降序
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}

// CPP version
void shell_sort(std::vector<int>& v)
{
    const int n = v.size();
    int gap = n;
    while (gap > 1)
    {
        gap = gap / 3 + 1;
        for (int i = 0; i + gap < n; ++i)
        {
            const int tmp = v[i + gap];
            int end_pos = i;

            while (end_pos >= 0)
            {
                if (std::less<int>()(tmp, v[end_pos]))
                    v[end_pos + gap] = v[end_pos];
                else
                    break;

                end_pos -= gap;
            }
            v[end_pos + gap] = tmp;
        }
    }
}

template<class compare>
void shell_sort(std::vector<int>& v, compare cmp)
{
    const int n = v.size();
    int gap = n;
    while (gap > 1)
    {
        gap = gap / 3 + 1;
        for (int i = 0; i + gap < n; ++i)
        {
            const int tmp = v[i + gap];
            int end_pos = i;

            while (end_pos >= 0)
            {
                if (cmp(tmp, v[end_pos]))
                    v[end_pos + gap] = v[end_pos];
                else
                    break;

                end_pos -= gap;
            }
            v[end_pos + gap] = tmp;
        }
    }
}
```







## 选择排序

### 选择排序

```c++
// C versuion
void SelectSort(int* a, int n)
{
	int begin = 0, end = n - 1;
	while (begin < end)
	{
		int maxi = begin, mini = begin;
		for (int i = begin; i <= end; ++i)
		{
			if (a[maxi] < a[i])
			{
				maxi = i;
			}
			if (a[mini] > a[i])
			{
				mini = i;
			}
		}
		Swap(&a[begin], &a[maxi]);
		//此时如果最小值下标在begin，交换一下，改变升降序时需改此处
		if (mini == begin)
			mini = maxi;
		Swap(&a[end], &a[mini]);

		begin++;
		end--;
	}
}

// CPP versuion
void select_sort(std::vector<int>& v)
{
    int lp = 0, rp = (v.size() > 0 ? v.size() - 1 : 0);
    while (lp < rp)
    {
        int left_p = lp, right_p = lp;
        for (int i = lp + 1; i <= rp; ++i)
        {
            if (std::less<int>()(v[right_p], v[i]))
                right_p = i;

            if (!(std::less<int>()(v[left_p], v[i])))
                left_p = i;
        }
        std::swap(v[lp], v[left_p]);
        // 此时如果最小值下标在lp，交换一下
        if(right_p == lp)
            std::swap(v[rp], v[left_p]);
        else
            std::swap(v[rp], v[right_p]);

        ++lp;
        --rp;
    }
}

template<class compare>
void select_sort(std::vector<int>& v, compare cmp)
{
    int lp = 0, rp = (v.size() > 0 ? v.size() - 1 : 0);
    while (lp < rp)
    {
        int left_p = lp, right_p = lp;
        for (int i = lp + 1; i <= rp; ++i)
        {
            if (cmp(v[right_p], v[i]))
                right_p = i;

            if (!(cmp(v[left_p], v[i])))
                left_p = i;
        }
        std::swap(v[lp], v[left_p]);
        // 此时如果最小值下标在lp，交换一下
        if (right_p == lp)
            std::swap(v[rp], v[left_p]);
        else
            std::swap(v[rp], v[right_p]);

        ++lp;
        --rp;
    }
}
```







### 堆排序

```c++
// C versuion
void AdjustDown(int* pa, int N, int parent)
{
	assert(pa);
	int MinChild = parent * 2 + 1;
	while (MinChild < N)
	{
		//if (MinChild + 1 < N && pa[MinChild] < pa[MinChild + 1])//大堆
		if (MinChild + 1 < N && pa[MinChild] > pa[MinChild + 1])//小堆
		{
			MinChild += 1;
		}
		//if (pa[MinChild] > pa[parent])//大堆
		if (pa[MinChild] < pa[parent])//小堆
		{
			Swap(&pa[MinChild], &pa[parent]);
			parent = MinChild;
			MinChild = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HeapSort(int* a, int n)
{
	assert(a);

	//建堆
	int i = 0;
	for (i = (n - 2) / 2; i >= 0; --i)//建小堆
	{
		AdjustDown(a, n, i);
	}

	for (i = 1; i < n; ++i)
	{
		Swap(&a[0], &a[n - i]);//置后，降序
		AdjustDown(a, n - i, 0);
	}
}

// CPP versuion
void adjust_down(std::vector<int>& v, int head_end, int parent)
{
    int min_child = parent * 2 + 1;
    while (min_child < head_end)
    {
        if (min_child + 1 < head_end && std::less<int>()(v[min_child], v[min_child + 1]))
        {
            ++min_child;
        }

        if (std::less<int>()(v[parent], v[min_child]))
        {
            std::swap(v[min_child], v[parent]);
            parent = min_child;
            min_child = parent * 2 + 1;
        }
        else
        {
            break;
        }
    }
}
template<class compare>
void adjust_down(std::vector<int>& v, int head_end, int parent, compare cmp)
{
    int min_child = parent * 2 + 1;
    while (min_child < head_end)
    {
        if (min_child + 1 < head_end && cmp(v[min_child], v[min_child + 1]))
        {
            ++min_child;
        }

        if (cmp(v[parent], v[min_child]))
        {
            std::swap(v[min_child], v[parent]);
            parent = min_child;
            min_child = parent * 2 + 1;
        }
        else
        {
            break;
        }
    }
}
void heap_sort(std::vector<int>& v)
{
    const int n = v.size();
    int i = 0;

    // 找最后一个元素的父节点，向下调整建树
    for (i = (n - 2) / 2; i >= 0; --i)
        adjust_down(v, n, i);

    for (i = 1; i < n; ++i)
    {
        std::swap(v[0], v[n - i]);
        adjust_down(v, n - i, 0);
    }
}

template<class compare>
void heap_sort(std::vector<int>& v, compare cmp)
{
    const int n = v.size();
    int i = 0;

    // 找最后一个元素的父节点，向下调整建树
    for (i = (n - 2) / 2; i >= 0; --i)
        adjust_down(v, n, i, cmp);

    for (i = 1; i < n; ++i)
    {
        std::swap(v[0], v[n - i]);
        adjust_down(v, n - i, 0, cmp);
    }
}
```









## 交换排序

### 冒泡排序

```c++
// C version
void BubbleSort(int* a, int n)
{
	for (int i = 0; i < n; i++)
	{
		int flag = 1;
		for (int j = 0; j < n - i - 1; j++)//调整升降序
		{
			if (a[j] < a[j + 1])
			{
				Swap(&a[j], &a[j + 1]);
				flag = 0;
			}
		}
		if (flag)
			break;
	}
}

// CPP version
void bubble_sort(std::vector<int>& v)
{
    int end = (v.size() > 0 ? v.size() - 1 : 0);
    while (end > 0)
    {
        for (int i = 0; i < end; ++i)
        {
            if (std::less<int>()(v[i + 1], v[i]))
                std::swap(v[i + 1], v[i]);
        }
        --end;
    }
}

template<class compare>
void bubble_sort(std::vector<int>& v, compare cmp)
{
    int end = (v.size() > 0 ? v.size() - 1 : 0);
    while (end > 0)
    {
        for (int i = 0; i < end; ++i)
        {
            if (cmp(v[i + 1], v[i]))
                std::swap(v[i + 1], v[i]);
        }
        --end;
    }
}
```







### 快速排序

```c++
// C version
int GetMid(int* a, int left, int right)
{
	int mid = (right + left) / 2;

	if ((a[mid] >= a[right] && a[mid] <= a[left]) || (a[mid] >= a[left] && a[mid] <= a[right]))
		return mid;
	else if ((a[left] <= a[right] && a[left] >= a[mid]) || (a[left] <= a[mid] && a[left] >= a[right]))
		return left;
	else
		return right;
}

// 快排的插入排序模块
void QuickInsertSort(int* a, int n)
{
	for (int i = 0; i < n - 1; ++i)
	{
		int end = i;
		int tmp = a[end + 1];
		//从0到end是有序的，插入后则从[0,end+1]是有序


		//移动数据再插入
		while (end >= 0)
		{
			if (a[end] > tmp)//调升降序
			{
				a[end + 1] = a[end];
				end--;
			}
			else
				break;
		}
		a[end + 1] = tmp;
	}

}

// 快速排序hoare版本
int PartSort1(int* a, int left, int right)
{
	int key = GetMid(a, left, right);
	Swap(&a[key], &a[left]);
	key = left;
	while (left < right)
	{
		while (a[right] >= a[key] && left < right)
			right--;

		while (a[left] <= a[key] && left < right)
			left++;

		if (left < right)
			Swap(&a[left], &a[right]);
	}
	Swap(&a[key], &a[left]);
	return left;
}

// 快速排序挖坑法
int PartSort2(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&a[mid], &a[left]);
	int key = a[left];
	while (left < right)
	{
		while (left < right && a[right] >= key)
			right--;
	
		if (left < right)
			a[left] = a[right];

		while (left < right && a[left] <= key)
			left++;

		if (left < right)
			a[right] = a[left];
	}
	a[right] = key;
	return right;
}


// 快速排序前后指针法
int PartSort3(int* a, int left, int right)
{
	int mid = GetMid(a, left, right);
	Swap(&a[mid], &a[left]);
	int key = a[left];
	int prev = left, cur = left + 1;
	while (cur <= right)
	{
		while (cur <= right && a[cur] >= key)
			++cur;

		if (prev < cur && cur <= right)
			Swap(&a[++prev], &a[cur]);

		++cur;
	}
	Swap(&a[left], &a[prev]);
	return prev;
}

void QuickSort(int* a, int left, int right)//right是闭区间右边界[left,right]
{
	if (left >= right)
		return;	

	if (right - left <= 16)//数据量小的序列直接使用插入排序
	{
		QuickInsertSort(a + left, right - left + 1);
	}
	else
	{
		//对此次序列进行排序
	    int key = PartSort1(a, left, right);
		//int key = PartSort2(a, left, right);
		//int key = PartSort3(a, left, right);

		//左半序列递归
		QuickSort(a, left, key - 1);
		//右半部分递归
		QuickSort(a, key + 1, right);
	}


}



// 快速排序 非递归实现
void QuickSortNonR(int* a, int left, int right)
{
	Stack sort;
	StackInit(&sort);
	StackPush(&sort, left);
	StackPush(&sort, right);
	while (!StackEmpty(&sort))
	{
		right = StackTop(&sort);
		StackPop(&sort);
		left = StackTop(&sort);
		StackPop(&sort);

		if (left >= right)
			continue;

		if (right - left <= 16)//数据量小的序列直接使用插入排序
		{
			QuickInsertSort(a + left, right - left + 1);
		}
		else
		{
			//对此次序列进行排序
			int key = PartSort2(a, left, right);
			StackPush(&sort, key + 1);
			StackPush(&sort, right);

			StackPush(&sort, left);
			StackPush(&sort, key - 1);
		}


	}


	StackDestroy(&sort);
}

// CPP version
int get_key(const int& range) { return rand() % range; }

// 标准模板，分三块  左闭右开
void part_sort(std::vector<int>& nums, int left, int right)
{
    if (left + 1 >= right) return;

    int key = nums[get_key(right - left) + left];
    int l = left - 1, r = right, i = left;
    while (i < r)
    {
        if (nums[i] < key)
            std::swap(nums[++l], nums[i++]);
        else if (nums[i] > key)
            std::swap(nums[--r], nums[i]);
        else
            ++i;
    }

    part_sort(nums, left, l + 1);
    part_sort(nums, r, right);
}

template<class compare>
void part_sort(std::vector<int>& nums, compare cmp, int left, int right)
{
    if (left + 1 >= right) return;

    int key = nums[get_key(right - left) + left];
    int l = left - 1, r = right, i = left;
    while (i < r)
    {
        if (std::equal_to<int>()(nums[i], key))
            ++i;
        else if (cmp(nums[i], key))
            std::swap(nums[++l], nums[i++]);
        else
            std::swap(nums[--r], nums[i]);
    }

    part_sort(nums, cmp, left, l + 1);
    part_sort(nums, cmp, r, right);
}

void quick_sort(std::vector<int>& nums)
{
    //srand((size_t)time(nullptr) ^ nums.size());
    part_sort(nums, 0, nums.size());
}
```





## 归并排序

```c
void Merge(int* a, int* disposal, int left, int right)
{
	if (left >= right)
		return;

	int mid = (left + right) / 2;
	Merge(a, disposal, left, mid);
	Merge(a, disposal, mid + 1, right);

	//选取数据合并
	int Ri = mid + 1;
	int Li = left;
	int i = 0;
	while (Li <= mid && Ri <= right)
	{
		if (a[Li] < a[Ri])//调整升降序
		{
			disposal[left + i] = a[Li];
			Li++;
		}
		else
		{
			disposal[left + i] = a[Ri];
			Ri++;
		}
		i++;
	}
	//将剩下的另一个未拷贝的数组继续拷贝
	while (Li <= mid)
	{
		disposal[left + i] = a[Li];
		Li++;
		i++;
	}
	while (Ri <= right)
	{
		disposal[left + i] = a[Ri];
		Ri++;
		i++;
	}

	//拷贝回原位置
	while (left <= right)
	{
		a[left] = disposal[left];
		left++;
	}
}


// 归并排序递归实现
void MergeSort(int* a, int n)
{
	//申请一块空间用于处理排序数据
	int* disposal = (int*)malloc(sizeof(int) * n);
	if (disposal == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}

	//将处理的过程交给函数模块去递归进行
	Merge(a, disposal, 0, n - 1);


	free(disposal);
	disposal = NULL;
}


// 归并排序非递归实现
void MergeSortNonR(int* a, int n)
{
	//申请一块空间用于处理排序数据
	int* disposal = (int*)malloc(sizeof(int) * n);
	if (disposal == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}
	
	int gap = 1;//迭代器
	while (gap < n)
	{
		for (int i = 0; i < n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;

			//end1越界
			if (end1 >= n)
			{
				break;
			}
			//begin2越界
			if (begin2 >= n)
			{
				break;
			}
			//end2越界
			if (end2 >= n)
			{
				end2 = n - 1;
			}
			//选取数据合并
			int j = i;
			while (begin1 <= end1 && begin2 <= end2)
			{
				if (a[begin1] < a[begin2])//调升降序
					disposal[j++] = a[begin1++];
				else
					disposal[j++] = a[begin2++];
			}

			while (begin1 <= end1)
				disposal[j++] = a[begin1++];

			while (begin2 <= end2)
				disposal[j++] = a[begin2++];

			//拷贝回去
			memcpy(a + i, disposal + i, sizeof(int) * (end2 - i + 1));
		}
		gap *= 2;
	}
	

	free(disposal);
	disposal = NULL;
}
```





```c
// 计数排序
void CountSort(int* a, int n)
{
	int i = 0;
	int max = a[0], min = a[0];
	for (i = 0; i < n; i++)
	{
		if (max < a[i])
			max = a[i];
		if (min > a[i])
			min = a[i];
	}

	//申请一块空间记录数字出现次数
	int* record = (int*)calloc((max - min + 1), sizeof(int));
	if (record == NULL)
	{
		perror("malloc failed");
		exit(-1);
	}

	//计数
	for (i = 0; i < n; i++)
		record[a[i] - min]++;

	int j = 0;
	for (i = 0; i < (max - min + 1); i++)
	{
		while (record[i])
		{
			a[j] = i + min;
			record[i]--;
			j++;
		}
	}

	free(record);
	record = NULL;
}
```



```c
int GetKey(int n, int k)
{
	int key = 0;
	while (k >= 0)
	{
		key = n % 10;
		n /= 10;
		k--;
	}
	return key;
}

void Classify(int* a,int n,Queue* RS,int k)
{
	for (int i = 0; i < n; i++)
	{
		int KeyI = GetKey(a[i], k);
		QueuePush(&RS[KeyI], a[i]);
	}
}

void Recycle(int* a,Queue* RS)
{
	int j = 0;
	for (int i = 0; i < Radix; i++)
	{
		while (!QueueEmpty(&RS[i]))
		{
			a[j++] = QueueFront(&RS[i]);
			QueuePop(&RS[i]);
		}
	}
}

//基数排序
void Radix_Sort(int* a, int n)
{
	Queue RS[Radix];
	for (int i = 0; i < Radix; i++)
	{
		QueueInit(&RS[i]);
	}
	for (int i = 0; i < K; i++)
	{
		//按基准分类数据
		Classify(a, n, RS, i);
		//从基准队列中返回数据
		Recycle(a, RS);
	}
	for (int i = 0; i < Radix; i++)
	{
		QueueDestroy(&RS[i]);
	}
}
```

